# dev-doc

## 开发计划

- 修改 Market `Done`
- 修改 WP/SLA `Done`
- 联调 Matket 和 WP/SLA `Done`
- 改进 WP 合约的 report 为秘密报告
- 单元测试 Market 合约函数
- 单元测试 WP 合约函数
- 设计命令行工具 cli，使用 cobra 编写
- 根据命令行工具 cli 的需要，写客户端
- 链端-客户端集成测试
- 生产环境部署
- 生产环境测试
- 制图
  - Order 状态图
  - 链端-客户端交互图
  - FaaS 用例图
- docker 为函数实体


## Provider 客户端设计

- bidder Pool
- accessSecretKey Pool

## ERC20

- https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md
- https://blog.51cto.com/13784902/2324024
- （标准实现）https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC20
- （可用实现）https://github.com/vittominacori/erc20-generator/tree/master/dist

-------------

## 使用代币支付

- https://ethfans.org/ajian1984/articles/816

-------------


## 市场合约

资金转帐流程：
1. 租户调用 token 合约的 approve，授权足够额度给市场合约
2. 租户调用市场合约的新建部署订单函数
3. 市场合约调用 token 合约的 transferFrom，锁定租户预付款
4. （省略若干无关资金的流程）
5. 服务时间到，订单完成，任何一方调用市场合约的 settle 函数，完成结算
6. 任何一方调用市场合约的 finish 函数，完成转账

---------

## 盲拍合约

- https://solidity-cn.readthedocs.io/zh/develop/solidity-by-example.html#id5
- https://solidity-cn.readthedocs.io/zh/develop/common-patterns.html#id5


-------------


## 客户端调用合约

1. 连接到区块链（client）
2. 构造合约实例（instance），需要地址（address），连接（client）
3. 调用合约函数

-------------


## 如何写出高质量设计说明文档

### 用什么“名”

> 名可名，非常名。

你这样说了，说明你的关注就是这个，所以实情就是这样。


> 执古之道以御今之有。能知古始，是谓道纪。

信息变大了，就成了恍惚，逼迫你进行特征提取和抽象。

我们理解一个人的观点，如果把目光看到他的构造逻辑链的时候，提取的是名所指向的恍惚中的哪个特征，我们可以更容易理解他真正的意思。

### 文档编写之『术』

『术』主要就是编写文档时结构上所需要素，这里分为了三类：

- 业务背景：首先编写文档时不要预设他人能理解所有的专业术语，其次要清楚地介绍业务存在的痛点，区块链能否解决这些痛点。
- 技术方案设计：需清晰地说明基础业务需求（如参与者、场景、活动），设计思路概要，详细的合约职责、函数、参数等。
- 使用说明：实际使用场景、上手指南和使用手册等。

### 文档编写之『道』

有了术，就能确保文档内容结构的完整性，文档就有了骨架和血肉；但是，『道』才是文档的灵魂和精髓所在，这里整理了5个关注点：

- 亮点：展示出本方案的独特性（创意/设计/功能/规范/文档）；
- 痛点：说清楚问题和解决方法；
- 重点：代码、注释、文档编写要条理清晰、可读性强，围绕问题和解决方案展开，不要为了炫技而炫技；
- 难点：基于智能合约特性，权衡规范、效率和安全性；
- 要点：以解释作为基本导向，不要预设别人能够理解所有业务和技术术语。


-------------


## 坑

- 坑一：solidity
    - solidity 版本
    - 引用类型（结构体，数组，映射）需要显式指定数据位置
    - 对于引用类型，状态变量向 storage 局部变量赋值时仅仅传递一个引用
    - 多重继承已最后继承的为主，故从左往右从祖先写到父亲
    - 外部创建合约 SC 的 sender 是 SC 的部署者，内部创建合约 SC 的部署者是 new SC 的合约
- 坑二：FISCO-BCOS 提供的 go-sdk 功能不完整
    - 0.10.3 版本的 go-sdk 不支持合约事件监听。。。
    - java-sdk 令人羡慕
- 坑三：无处不在的安全漏洞
    - 智能合约的整数溢出（合约里的算术运算都是不安全的！！！）
        - SafeMath
    - 智能合约的恶意重入（还没有检查可能的 bug！！！）
        - 在你合约中状态变量进行各种变化后再调用外部函数，这样，你的合约就不会轻易被滥用的重入 (reentrancy) 所影响
        - 多发生在 withdraw 函数
        - 解决方法：“检查-生效-交互”（Checks-Effects-Interactions）模式
    - 非对称加密（该加密的地方还没有加密！！！）
- 坑四：token 的 approveAndCall 是糟糕的转帐方式
- 坑五：配置地狱
    - 区块链节点的IP地址，端口配置
    - 客户端的证书配置
        - ca.crt CA 根证书文件
        - sdk.crt SDK 证书文件
        - sdk.key SDK 私钥文件
    - 公钥账户配置



## 2021-03-09 讨论

### 1. 如何产生区块链上的随机性？

我们会为每个有效的租约建立一个 SLA 的监督，每当新建一个 SLA 的监督，WitnessPool 合约需要从证人池中 **无偏随机地** 抽选的证人。 

这就考虑到，如何在区块链上产生随机性？

从理论上来说，区块链不可能具有内生随机性，其随机性只能来自外部。

在论文 [Blockchain based Witness Model](https://pure.uva.nl/ws/files/42160225/Blockchain_based_Witness_Model.pdf) 中，其描述的随机抽选算法的种子是根据区块链上未来产生的区块的哈希来计算，其随机性来源于未来时间里各方参与区块链的不确定性。
具体来说，当发出一个抽签请求时，记录该请求当前的块号 `curBlockNum` ，等待一段时间后（为了等待未来区块的产生），然后根据 `curBlockNum+1`，`curBlockNum+2` 到 `curBlockNum+blockNeed` 这`blockNeed` 个区块的哈希来计算种子。

如果攻击方想操纵随机性，那么它至少需要控制这 `blockNeed` 个区块的哈希值。

```

  新租约                        新 SLA 
  curBlockNum             curBlockNum+blockNeed
   |                                 |
   |                                 |
  \|/                               \|/
=====================================================================> 区块链
    |                                 |
    |  seed = sum(blockhash)          |
    |                                 |
    ---------------------------------- 随机性来源

```



论文中这种产生随机性的做法会面临的工程上的问题：

solidity 中只支持访问最近 256 个区块的哈希值，不在该范围的区块的哈希值为 0。

如果，“等待一段时间”过久，其间区块链已产生超过 256 个区块，那么 `curBlockNum+1` 等区块的哈希信息就会消失，这在区块链上很不好控制。



为了解决这个问题，我想一个办法，由 `curBlockNum` 和 `block.number` 来衍生一个 `pivotBlockNum`,

```
uint _pivotBlockNum = block.number - ( block.number - _curBlockNum ) / 1024 - _blockNeed;
```

```

  新租约                                                            新 SLA
  curBlockNum     pivotBlockNum        pivotBlockNum+blockNeed     block.number
   |                    |                         |                    |
   |                    |                         |                    |
  \|/                  \|/                       \|/                  \|/                          
========================================================================> 区块链
                         |                         |
                         |  seed = sum(blockhash)  |
                         |                         |
                         --------------------------- 随机性来源

```

只有在 ( `block.number` - `curBlockNum` ) > 1024（缩小系数）* 256（EVM blockhash 深度限制）= 2^18 的时候，哈希信息才会消失。




### 2. 是否能以给证人奖励的方式来增发 token？

给证人奖励资金来源于哪里，有两种方法：

- 一种是由租户和供应商共同负担
- 一种是凭空增加 token 给证人，以这种方式增发 token



### 3. 访问函数是否需要 authentication ？

对于一个有效的 FaaS 租约，供应商为租户在一个地址上部署了一个 HTTP 函数，访问这个 HTTP 函数是否需要鉴权？

- 如果没有鉴权
    - 受 DoS 攻击的风险更大

- 如果需要鉴权，就会导致一个问题，证人需要访问这个 HTTP 函数来判定供应商是否违约？

    鉴权的方法是，供应商预先在区块链上公布一串哈希值 H ，租户想访问函数的话，就要把 H 用租户的私钥加密，得到加密后的值 H'，然后供应商会根据租户的公钥来验证 H' 是否确实租户发出的。

    此外，还需要有处于安全考虑的访问次数的限制，
        - 租户没有访问次数的限制
        - 证人有访问次数的限制，防止证人借监督之便滥用租户付费购买的资源
    


### 4. 在区块链上实现博弈论的假设条件


证人之间的博弈是静态博弈，更准确地，是完全信息静态博弈。

静态博弈的一个假设是：player 不知道其他 player 采取了什么策略。

由于在区块链上，任何信息都是公开的，所以证人不可以直接把监督结果发送到区块链上，因为其他证人可以看到，这就破坏了博弈的假设。

我们可以使用类似于盲拍的技术，来实现静态博弈的这个假设条件。

证人上报监督结果分为两个阶段：一个是 秘密报告 阶段，一个是 披露 阶段。

- 秘密报告阶段：证人向合约发送一个哈希值 H

- 披露阶段：证人向合约发送监督结果 B 和 一个密钥 S，链端验证秘密报告阶段 H = hash(B，S)


### 5. 供应商贿赂证人怎么办？


在本设计中，由于引入了证人机制和函数鉴权，供应商明确知道负责执行租约 SLA 的证人。

如何防止供应商贿赂证人？


由于证人之间的博弈仅存在两个纳什均衡，供应商的贿赂要成功，供应商需要贿赂大多数（> M）的证人。



## 6. 怎么把 HTTP function 包成 docker image ？



------------









