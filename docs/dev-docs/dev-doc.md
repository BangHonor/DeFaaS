# dev-doc

## 开发计划

- 修改 Market `Done`
- 修改 WP/SLA `Done`
- 联调 Matket 和 WP/SLA `Done`
- 改进 WP 合约的 report 为秘密报告
- 单元测试 Market 合约函数
- 单元测试 WP 合约函数
- 设计命令行工具 cli，使用 cobra 编写
- 根据命令行工具 cli 的需要，写客户端
- 链端-客户端集成测试
- 生产环境部署
- 生产环境测试
- 制图
  - Order 状态图
  - 链端-客户端交互图
  - FaaS 用例图
- docker 为函数实体


## 实现细节

### Provider 客户端设计

- bidder Pool
- accessSecretKey Pool

### ERC20

- https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md
- https://blog.51cto.com/13784902/2324024
- （标准实现）https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC20
- （可用实现）https://github.com/vittominacori/erc20-generator/tree/master/dist


### 使用代币支付

- https://ethfans.org/ajian1984/articles/816



### 客户端调用合约

1. 连接到区块链（client）
2. 构造合约实例（instance），需要地址（address），连接（client）
3. 调用合约函数



### 客户端监听合约事件

- https://goethereumbook.org/zh/event-subscribe/

-------------


## 如何写出高质量设计说明文档

### 用什么“名”

> 名可名，非常名。

你这样说了，说明你的关注就是这个，所以实情就是这样。


> 执古之道以御今之有。能知古始，是谓道纪。

当考虑的要素越来越多的时候，要正确判断一件事情，一个概念， 也就越加的不容易。

信息变大了，就成了恍惚，逼迫你进行特征提取和抽象。

我们理解一个人的观点，如果把目光看到他的构造逻辑链的时候，提取的是名所指向的恍惚中的哪个特征，我们可以更容易理解他真正的意思。

架构师：基于模型“证明”需求的可实现性，创造出“概念”，概念是谎言。

设计师和工程师：基于技术推演“证明”概念的可实现性，圆了架构师的谎。

> 守弱

你得先去建立做事情本身的经验才能来谈哲学的呀。

决策是个综合逻辑，给你一个信息是给你提供帮助，不是让你用那个信息作为决策结论啊，但也不表示你要把所有信息“规整化”为决策的那个样子。

为什么总是越过最重要的“现在”，想“未来”和“占有”的问题呢？

你对现实一无所知，指望用道理的道理去Cover细节？这有可能吗？

所以读者们是否明白“守弱”是什么？“守弱”是在决策思维的时候，守着身边的“辎重”，而不是守着远处的“信息”和“期望”来做决策。决策的第一依据是“我有多少粮食在车上”，然后才是“远处有绿洲”，“另一个方向有城市”，还有一个方向有“金矿”……“守”是脑子的落足点，“弱”是决策点和自身“辎重”的距离。我们优先采纳我有多少粮食这个判断依据，其他的遥远的东西执行度要梯级下降，这样我们的决策才是保险的。

我们决定下一步，必然要考虑未来，未来（离现在）稍远，我们的判断就无力了。所以“前识着，道之华而愚之始也”。我们要判断，就要“前识”，前识必然不是现实，它是我们
从已有的道中观察出来的规律来进行判断，这个判断越靠近已有的现实，准确度就越高。所以我们必须步步为营，每步都和现实对照。而不是活在自己营造的“未来世界”中，维持自己的“道理”。


### 文档编写之『术』

『术』主要就是编写文档时结构上所需要素，这里分为了三类：

- 业务背景：首先编写文档时不要预设他人能理解所有的专业术语，其次要清楚地介绍业务存在的痛点，区块链能否解决这些痛点。
- 技术方案设计：需清晰地说明基础业务需求（如参与者、场景、活动），设计思路概要，详细的合约职责、函数、参数等。
- 使用说明：实际使用场景、上手指南和使用手册等。

### 文档编写之『道』

有了术，就能确保文档内容结构的完整性，文档就有了骨架和血肉；但是，『道』才是文档的灵魂和精髓所在，这里整理了5个关注点：

- 亮点：展示出本方案的独特性（创意/设计/功能/规范/文档）；
- 痛点：说清楚问题和解决方法；
- 重点：代码、注释、文档编写要条理清晰、可读性强，围绕问题和解决方案展开，不要为了炫技而炫技；
- 难点：基于智能合约特性，权衡规范、效率和安全性；
- 要点：以解释作为基本导向，不要预设别人能够理解所有业务和技术术语。


-------------


## 坑

### solidity

- solidity 版本
- 引用类型（结构体，数组，映射）需要显式指定数据位置
- 对于引用类型，状态变量向 storage 局部变量赋值时仅仅传递一个引用
- 多重继承已最后继承的为主，故从左往右从祖先写到父亲
- 外部创建合约 SC 的 sender 是 SC 的部署者，内部创建合约 SC 的部署者是 new SC 的合约

### 安全漏洞

- 整数溢出
    - SafeMath
- 恶意重入
    - 在你合约中状态变量进行各种变化后再调用外部函数，这样，你的合约就不会轻易被滥用的重入 (reentrancy) 所影响
    - 多发生在 withdraw 函数
    - 解决方法：“检查-生效-交互”（Checks-Effects-Interactions）模式
- 非对称加密



## TODO

### 生产环境中的安全配置

开发环境下，使用的连接是不安全。

在生产环境，需要做一些安全工作：

- 配置 SSL

    - 把 http 配置为 https

    - 把 ws 配置为 wss


    解决方案：反向代理 https://ethereum.stackexchange.com/questions/26026/how-to-ssl-ethereum-geth-node


- 访问限制

    - http.corsdomain 的跨域限制

    - ws.origins 的访问限制

    解决方案：仍然通过代理服务器来处理，不在 geth 节点这一层解决。




 git config --local http.proxy 127.0.0.1:8889 && git push origin master







