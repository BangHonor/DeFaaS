# DeFaaS: an Open and Fair FaaS Platform based on Blockchain

## 1. 背景

### 1.1 选题背景与意义

> 这一节主要说明：**Fair** 和 **Open** 的意义



云计算是一种重要的使用计算机资源的方式。

传统云计算的商业模式是，**租户**付费使用云计算**供应商**所建立的数据中心里的计算机资源。

- 这种商业模式的一个缺点是，租户无法对供应商的服务水平进行有效的监督。

  （ 如果有一个可信的，租户和供应商外的第三方可以进行监督供应商的服务水平，就有了 **Fair**，对租户 Fair）

- 另一个缺点是，如果租户租用的云计算资源被闲置了，这对租户来说意味着资源的浪费和损失。

  （如果这些闲置计算机资源的所有者有机会成为供应商，把资源提供给需要的人，就有了 **Open**，对供应商 Open）



区块链技术的出现，使得我们可以克服这两种缺点。



本设计基于区块链技术，设计了一个开放公平的 FaaS 计算平台：

- 开放体现在，任何人可以成为租户，任何人可以成为供应商
- 在 FaaS 平台，供应商能以为租户运行函数服务的方式提供计算资源
- 在 FaaS 平台，租户能以部署函数服务的方式消费计算资源，同时本平台提供可信的服务水平协议，与中心化的云供应商相比，本平台对租户更加公平。



下图是本 FaaS 平台的 **用例图**，包含所有顶层约束。



![](./defaas-imgs/Usecase.svg)





### 1.2 智能合约的背景（提纲）

> 这一节主要说明：为什么需要区块链和智能合约？
>
> 简单来讲：通过 去中心化，不可篡改，自动执行 等的技术特性解决 业务逻辑 中 参与者 对 合作规则 的信任问题。

- 租户和供应商之间交易计算资源，需要在一个“规则”下合作，这个“合作规则”要能够得到租户和供应商的”信任“，而使用区块链技术，可以构建这个“信任”

- （稍微介绍一下区块链，智能合约，这里先 pass）

- 区块链建立在共识之上，对链上数据的修改是去中心化的，没有一方能单独篡改区块链上的数据，所以数据的公开透明产生了信任

- 智能合约是不可变的”合作规则“，智能合约的自动执行是”规则“的严格执行，所以“规则的不可变”和“规则执行的不可操纵”产生了信任

- 把智能合约作为”合作规则“的形式，解决了"合作规则"的信任问题，但这只是最基本的信任问题，应用层还有其他信任问题。

  问题进一步推进到了如何设计”合作规则“（解决应用层的信任问题）来吸引各方参与？



### 1.3 FaaS 的背景（提纲）

> 这一节主要说明：为什么是 FaaS 的形式？
>
> 简单来讲：无状态。

- 从隐私角度，数据所有权的角度解释为什么采用 FaaS 这种无状态的的形式来使用计算资源，而不是数据库等有状态的形式

- 讲述 FaaS 的特点和发展现状，说明 FaaS 是有用武之地的
  - 举一些典型例子：可以做 AI 推理，图像处理等



### 1.4 本文的论文结构和章节安排

本文共分为八章，各章节内容安排如下：

- 第一章为背景。说明了本文章的选题背景与意义。
- 第二章为本文的概述。介绍本设计的核心概念，用例和整体设计。
- 第三章，第四章为第二章的细化。
  - 第三章介绍 **Open** 怎么来的：去中心化的 FaaS 市场
  - 第四章介绍 **Fair**    怎么来的：可信的服务水平协议
- 第五章介绍了一些重要的细节。这些细节用于保护 Open 和 Fair 的逻辑没有漏洞，从而证明本设计的可行性。
- 第六章指出了一些本设计的不足
- 第七章介绍了相关工作
- 第八章是结论与展望





------

## 2. 概述

### 2.1 概念介绍

#### 2.1.1 账户与角色

本 FaaS 平台基于**采用公私钥体系**的区块链，**区块链的账户就是本平台的账户**。根据非对称加密技术，一个账户对应着一对公钥和私钥，由公钥经过安全单向的计算后得到地址字符串被用作账户的账户名，即**账户地址**。

任何人可以自行生成账户参与到本平台中，不需要经过任何请求和审核。



一个账户可以扮演三种角色：

- 租户 Customer

  租户能发出函数服务的订单，以部署函数服务的方式消费计算资源。

- 供应商 Provider

  对于租户发出的函数服务的订单，供应商提供计算资源来运行这些函数服务。

- 证人 Witness

  证人监测供应商运行的函数服务并向平台报告，维持可信的服务水平协议（Trustworthy Service Level Agreement ）。



#### 2.1.2 FaaS Token

本平台设计了一个符合 ERC20 标准，名为 FaaS Token 的合约，它创造了一种名为 **FST** 的代币。

FST 是一种仅可用于本平台的货币。作为一种电子形式的价值符号，它有两个作用：

- 作为租户消费计算资源的支付手段。

  **租户需要为其部署的函数服务支付 FST 给平台，而供应商通过为租户运行函数服务来从平台获取 FST。** 

- 作为质押资产。

  一个参与者可以质押一定的 FST 给平台，从而注册成为供应商或证人。



FST 有两个含义：

- 在本平台中，FST 是交换计算资源的媒介（media）
- 在本平台中，FST 是使用计算资源的权力（power）



### 2.2 整体设计

如下图，整体上看，本平台设计了：

- 两个智能合约：Market 合约 和 WitnessPool 合约
- 三种角色的客户端：租户，供应商，证人

通过三种角色和两个智能合约的交互，**形成了一个 可信的 FaaS 算力市场**，来完成 1.1 中陈述的用例。



关系图：

<img src="./defaas-imgs/Overview-Design.svg" style="zoom:150%;" />



上图中**左半部分**将在第三章中详细介绍，**右半部分**将在第四章中详细介绍。





```
// 阅读中请跳过此部分
// 无处安放的概述

合约功能概述
- Market 合约的功能有：
  - 管理供应商（Provider Management）
  - 管理 FaaS 服务规格（FaaS Level）
  - 作为 FaaS 服务的市场（Market）
- WitnessPool 合约的功能有：
  - 管理证人（Witness Management）
  - 抽选证人，执行 SLA （Witness Pool）
```



-----------

## 3. 去中心化的 FaaS 市场

租户和供应商 同  Market 合约 的交互形成了一个去中心化 FaaS 市场。

为了部署函数服务，租户需要向 Market 合约发出部署请求；再经过一系列的智能合约交互，租户与供应商之间达成租约，供应商开始为租户运行函数服务；最后，当函数服务结束，Market 合约会为双方完成结算和转账。

### 3.1 计费规则

#### 3.1.1 按服务时长计费

> 为什么按服务时长计费？
>
> FaaS 的好处之一是弹性，对于有弹性需求的场景，理当是按需使用，产生的费用由 function 实际调用次数决定，服务费用不能提前确定，而在开放的环境下，由供应商记录的调用次数又是不可信的。
>
> 我们这里不得不简化，舍去弹性的优势，计费方法按使用时长来计费，面向的是**大任务离线计算**这类函数计算：供应商以 PaaS 的方式出售计算资源，而租户只以 FaaS 的方式来利用。
>
> 安全性限制了本平台的应用范围。
>
> 解决 函数调用次数的信任问题 得到的好处是可以落实弹性计费，扩大了平台的应用范围；**或许有密码学技术可以解决这个问题？或者采用可信第三方在中间转发来解决这个信任问题？**



如在 2.1.2 中所述，租户需要为其部署的函数服务支付 FST 给平台，其计费规则如下：
$$
ServiceFee =  ServiceDuration  \times UnitPrice
$$
其中，

- ServiceFee 是租户部署一个函数服务需要支付给 FaaS 平台的 FST 数目。
- ServiceDuration  是 FaaS 服务时长，以小时为单位。
- UnitPrice 是服务单价，即每小时的单价，不同的 **FaaS 服务规格（FaaS Level）**有不同的单价。



#### 3.1.2 FaaS 服务规格

Market 合约维护了一个类似下表的 **FaaS 服务规格表**，指明一个函数服务所能使用的最大计算资源。

租户想要部署一个函数服务，必须指定一个 FaaS 服务规格的 **ID**。



*FaaS 服务规格表*

| FaaS 服务规格 ID | CPU核心数 | 使用内存（MB） | 函数镜像大小（MB） | ...（其他字段） |
| ---------------- | --------- | -------------- | ------------------ | --------------- |
| 0                | 1         | 512            | 50                 | ...             |
| 1                | 1         | 1024           | 100                | ...             |
| 2                | 2         | 2048           | 200                | ...             |
| ...              | ...       | ...            | ...                | ...             |



### 3.2 竞价匹配机制

本平台中，租户想要部署一个函数服务，他要先发出一个**部署请求**（Deployment Request）给 Market 合约。Market 合约在受到部署请求后会新建一个**部署订单**（Deployment Order）并产生事件，部署订单记录了租户指定的 FaaS 规格，FaaS 服务时长，租户可接受的最高单价等信息。供应商们通过监听 Market 合约上的事件，可以获知新部署订单的信息。

我们说一个部署订单被**匹配**了（Matched），当 Market 合约上决定由某一个供应商来运行部署订单对应的函数服务。那么，如何决定是哪一个供应商？**部署订单的匹配是通过供应商之间的竞争来完成的。**如 3.1.1 所述的计费规则，服务费用是服务时间和服务单价的乘积；供应商之间要竞争的内容是服务单价，要价越低的供应商越有可能获得订单。

竞价匹配规则如下：

- 对于一个部署订单，在订单指定的竞标时间内，供应商可以对该订单的**投标**（Bid），即向 Market 提交一个服务单价（是供应商为租户运行函数服务的要价）
- 当订单指定的竞标时间到达后，Market 合约上会产生匹配结果：
  - 如果竞标期间没有一个供应商对该订单投标，那么说明没有供应商愿意为此订单运行函数服务，订单**匹配失败**。
  - 只要存在至少一个供应商对该订单投标，订单就可以**匹配成功**。多个供应商的投标按如下规则胜出一个供应商：
    - 要价最低的供应商胜出
    - 相同要价下，更早投标的供应商胜出



> 为什么引入竞价？
>
> - 根据现实的情况，有大量潜在的供应商，计算机设备不管使不使用都是在折旧
>
> - 如果大量的供应商涌入市场，价值规律的调节可使租户获得比中心化云厂商更便宜的价格



### 3.3 部署订单，部署信息和租约

当一个部署订单匹配成功，说明租户与供应商谈好了价钱。对于一个函数服务，租户与供应商之间还需要协商的服务的**访问地址**，**访问密钥**等细节，这些细节称为**部署信息**（Deployment Information）。

在一个部署订单匹配成功之后，进一步地，需要前后相继的两个步骤：

1. 供应商把部署信息发到 Market 合约上
2. 租户从 Market 合约获取供应商提交的部署信息

经过这两个步骤后，Market 合约会为租户与供应商新建**租约**（Lease），租约记录了双方的账户地址，供应商应得服务报酬，供应商是否违反 SLA 等信息。



如下图，Market 合约在链上维护了 FaaS 规格表，部署订单表，部署信息表，租户表这四个表，后三者都以 部署请求ID 为主键。



<img src="./defaas-imgs/Market-Core-Data.svg" style="zoom:150%;" />



> 部署订单，部署信息，租约都以部署请求 ID 为主键，为何要拆分称三个表？
>
> 这受 EVM 上结构体的存储方式的约束。此三个数据结构在 Market合约都中以结构体保存。
>
> 如果把三个表合成一个大表，大表的一行大小就相当于原来三个表的一行大小的总和。但是，如果部署请求的状态在某个步骤停滞了，如，部署订单匹配匹配失败了，或者供应商迟迟没有发出部署信息，那么 Market 合约只需要开辟空间存放“部署订单”这部分数据，不需要开辟空间存放“部署信息”，“租约”那部分数据。
>
> 拆成三个表有更低的空间开销。而 FaaS 规格表的划分是关系数据模式的范式化。





### 3.4 部署请求的状态机

Market 合约中，一个部署请求由如下的有限状态机控制。图中，

- C 表示租户（Customer），P 表示供应商（Provider），X 表示任何人

- C-> new 表示租户调用 Market 合约的 new 函数，诸如此类



<img src="./defaas-imgs/Deployment-FSM.svg" style="zoom:150%;" />



一个部署请求有六个状态：

- Bidding（竞标中），本状态以租户调用 Matket 合约的 new 函数**新建部署订单**为开始，以竞价终止为结束
- Confirming（确认中），本状态以部署订单匹配成功为开始，在本状态中供应商和租户确认订单并提供部署信息，以**新建租约**为结束
- Deploying（部署中），本状态以新建租约为开始，在本状态中，链下租户到供应商部署函数服务，以租户触发Fulfilling状态为结束
- Fulfilling（履行中），本状态以新建 SLA 为开始，在状态中，证人监督供应商，以任意人触发Settled状态完成结算为结束
- Settled（已结算），本状态中账目已结算清楚但还没有转账，以任意人触发Finished状态完成转账为结束
- Finished（已结束），为终止状态，此状态中已完成转账，部署请求生命周期终止





Market 合约的**交互图**：

<img src="./defaas-imgs/Market.svg" style="zoom:150%;" />





在部署请求的生命周期中，**资金转账流程**为：

1. 租户调用 FaaS Token 合约的 approve，授权足够额度给 Market 合约
2. 租户调用 Matket 合约的 new 函数，在 new 函数中，Market 合约调用 FaaS Token 合约的 transferFrom，锁定租户的**预付款**
3. （省略若干无关资金的流程）
4. 服务时间到，供应商履行租约结束，任何一方调用 Market 合约的 settle 函数，完成结算
5. 任何一方调用 Market 合约的 finish 函数，完成转账





### 3.4 供应商之间的秘密竞价（未敲定的细节）

秘密竞价指供应商之间的出价是秘密，可以防止供应商形成卖方联盟。

https://solidity-cn.readthedocs.io/zh/develop/solidity-by-example.html#id5





```
供应商：鉴权（未敲定的细节）

对于一个有效的 FaaS 租约，供应商为租户在一个地址上部署了一个 HTTP 函数，访问这个 HTTP 函数是否需要鉴权？

- 如果没有鉴权

  - 受 DoS 攻击的风险更大

- 如果需要鉴权，就会导致一个问题，为了判定供应商是否违约，证人也需要访问这个 HTTP 函数

  鉴权的方法是：

  - 供应商预先在区块链上公布一串哈希值 H 
  - 租户想访问函数的话，就要把 H 用租户的私钥加密，得到加密后的值 H'，然后供应商会根据租户的公钥来验证 H' 是否确实租户发出的

  此外，还需要有处于安全考虑的访问次数的限制：

  - 租户没有访问次数的限制 
  - 证人有访问次数的限制，防止证人借监督之便滥用租户付费购买的资源
```





## 4. 可信的服务水平协议

### 4.1 SLA

本 FaaS 平台是开放的，所有人都可以参与其中，得益于区块链技术，平台的合作规则得到了参与者的信任。

然而，在业务层面，一个陌生的租户把函数服务交给一个陌生的供应商运行，我们也面临着一个中心化云供应商面临的信任问题：**供应商是否诚实地为租户运行函数服务？** 更具体地，供应商到底有没有运行函数服务？供应商提供的计算资源符合部署订单指明的 FaaS 规格吗？供应商运行的函数服务的可用性如何？这些需求指标和性能指标可以总结为**服务水平协议（Service Level Agreement，SLA）**。

当租户与供应商达成了租约，也意味着他们达成了 SLA；相比于中心化的云供应商，如果本平台能够提供可信的 SLA，对租户就会更加公平。那么，在一个开放的环境中，FaaS 平台如何保证 SLA 是可信的？如何判断供应商违反了SLA？

一个直观的想法是，可以引入独立的第三方机构来**监测**（Monitoring）供应商的函数服务，从而判断供应商是否违约。

但是首先，我们不能引入一个中心化的第三方来实施监测，因为中心化的第三方不被信任。本平台解决了这一信任问题，通过引入**证人机制**，一个去中心化的第三方。“证人机制”这个想法来自于 [Blockchain based Witness Model](https://pure.uva.nl/ws/files/42160225/Blockchain_based_Witness_Model.pdf)。



### 4.2 WitnessPool 合约

如 2.1.1 中介绍，一个账户还可以扮演一种角色：证人。

证人的作用是监测供应商运行的函数服务并向 WitnessPool 合约报告**监测结果（一个布尔值）**：

- 监测结果为 True 表示证人认为供应商违约了
- 监测结果为 False 表示证人认为供应商没有违约



交互图：

<img src="./defaas-imgs/Witness.svg" style="zoom:150%;" />

如 3.4 中所述，当一个部署请求处于 Deploying 状态时，租户在供应商上部署完函数服务后，可以调用 Market 合约的 fulfill 函数，使部署请求状态转变到 Fulfilling 状态。在 fulfill 函数中，Matket 合约将调用 WitnessPool 合约，为该部署请求新建了一个监测 SLA 的**证人委员会**（Wintess Committee）。

证人委员会的人数 N（N >= 3）是可以指定的。

假设一个证人委员会包含了 N 个证人，他们分别监测函数服务并向 WitnessPool 合约报告监测结果。

在 WitnessPool 中，以如下规则判定供应商是否违约：

- 对应一个 N，WintessPool 中会规定一个相对多数 M（N/2 < M < N），比如说 N = 3， M = 2
- 如果认定供应商违约的人数 W >= M，那么 WitnessPool 合约就认定供应商违约（Violated）；反之则不违约（NoViolated）。





### 4.3 博弈论结论

证人报告监测报告可以得到报酬（payoff），设计其 payoff 如下所示：

记 WitnessPool 认定供应商是否违约的值为 **S**，S = Violated 或者 S = NoViolated。

| S /  证人的监测报告 | True | False |
| ------------------- | ---- | ----- |
| Violated            | 10   | 0     |
| NoViolated          | -1   | 1     |

N 个证人的监测报告形成了一个一回合的 n-player game。



在论文[Blockchain based Witness Model](https://pure.uva.nl/ws/files/42160225/Blockchain_based_Witness_Model.pdf) 中，证明了这个 n-player game 有且仅有两个**纳什均衡**：

- 一个纳什均衡是要么所有证人都报告 True
- 另一个纳什均衡是要么所有证人都报告 False

一个证人为了最大化收益，会选择符合纳什均衡的策略，但是令他难以判断的是，其他证人是都选择 True，还是都选择 False；对应一个证人来说，最好的方法是根据监测情况如实报告，因为他和其他的所有证人都看到同样的现实。

所以，尽管单个证人是不可信的，但是由于证人之间的博弈制衡，证人委员会里的证人都将**如实报告**供应商是否违约，这形成了一个去中心化的可信第三方，依靠这个第三方， FaaS 平台维持了可信的 SLA，给租户带来了 Fairness。



最后，需要提的是，证人的监督报酬不是由租户或者供应商承担，而是来自 FaaS 平台的凭空铸币。





### 4.4 链端：保证静态博弈的假设

- 为什么要保证静态博弈的假设？

  博弈的假设是博弈结论成立的条件，只有保证博弈的假设，我们在第四章中提到的博弈论结论才能成立。

- 区块链的公开透明特性与静态博弈假设的冲突

  证人之间的博弈是静态博弈，更准确地，是完全信息静态博弈。

  静态博弈的一个假设是：player 不知道其他 player 采取了什么策略。

  由于在区块链上，任何信息都是公开的，所以证人不可以直接把监督结果发送到区块链上，因为 晚报告的证人 可以看到 先报告的证人的报告结果，这就破坏了博弈的假设。

- 提出解决办法

  我们可以使用类似于盲拍的技术，来实现静态博弈的“player 不知道其他 player 采取了什么策略”这个假设。

  证人上报监督结果分为两个阶段：一个是 秘密报告 阶段，一个是 披露 阶段。

  - 秘密报告阶段：证人向 WitnessPool 合约发送一个哈希值 H，H 即秘密报告。证人只能在该阶段报告
  - 披露阶段：证人向合约发送监督结果 B，一个时间值 T 和 一个密钥 S，链端验证秘密报告阶段 H = hash(B, T, S) 并且 T 在一个合理的时间区间内（在当前时刻附近）。

  安全性分析：一个证人，对于不同的监督结果 B，B‘ ，他很难找到一对可以作弊的 S 和 T， 使得 hash(B, T, S) = hash(B', T, S)；并且他也不能预先计算作弊的 S 和 T，因为要求 T 在合理的区间内。





### 4.5 链端：证人的随机抽取

- 为什么要随机抽取证人？

  使证人不偏向租户和供应商中的任何一方。

- 讲述引用的论文中做法和工程困难

  - 从理论上来说，区块链不可能具有内生随机性，其随机性只能来自外部。

  - 在论文 [Blockchain based Witness Model](https://pure.uva.nl/ws/files/42160225/Blockchain_based_Witness_Model.pdf) 中，其描述的随机抽选算法的种子是根据区块链上未来产生的区块的哈希来计算，其随机性来源于未来时间里各方参与区块链的不确定性。 具体来说，当发出一个抽选请求时，记录该请求当前的块号 `curBlockNum` ，等待一段时间后（为了等待未来区块的产生），然后根据 `curBlockNum+1`，`curBlockNum+2` 到 `curBlockNum+blockNeed` 这`blockNeed` 个区块的哈希来计算种子。

  ```python
    新建租约                        新建 SLA 
    curBlockNum             curBlockNum+blockNeed
     |                                 |
     |                                 |
    \|/                               \|/
  =====================================================================> 区块链
      |                                 |
      |  seed = sum(blockhash)          |
      |                                 |
      ---------------------------------- 随机性来源
  
  ```

  

  - 论文中这种产生随机性的做法会面临的工程上的问题：

    solidity 中只支持访问最近 256 个区块的哈希值，不在该范围的区块的哈希值为 0。

    如果，“等待一段时间”（  新建租约 到 新建SLA 的时间）过久，其间区块链已产生超过 256 个区块，那么 `curBlockNum+1` 等区块的哈希信息就会消失，这在区块链上难以控制。

  

- 提出解决方法并进行安全性分析

  - 为了解决上述工程问题，我想一个办法，由 `curBlockNum` 和 `block.number` 来衍生一个 `pivotBlockNum`,

    ```go
    uint _pivotBlockNum = block.number - ( block.number - _curBlockNum ) / 1024 - _blockNeed;
    ```

    其中 1024 是一个放大系数。

    ```python
    新建租约                                                    新建 SLA
    curBlockNum  pivotBlockNum  pivotBlockNum+blockNeed   block.number
       |                    |                |               |
       |                    |                |               |
      \|/                  \|/              \|/             \|/                          
    ==================================================================> 链
                            |                 |
                            | seed =          |
                            | sum(blockhash)  |
                            |                 |
                            ------------------ 随机性来源
    ```

    只有在 ( `block.number` - `curBlockNum` ) > 1024 * 256（EVM blockhash 深度限制）= 2^18 的时候，哈希信息才会消失。

- 安全性分析

  攻击者可以用 DoS 攻击来操纵区块的哈希，但是它很难控制种子产生的一系列伪随机数恰好选中它所串通的证人。







## 5. 算池

### 5.1 算池供应商

- 从”矿池“到”算池“

  比特币的最初设想是网络节点是去中心化的，每个区块链网络节点都只有很小的计算能力，但是现实的发展是出现了 PoW 挖矿中心——矿池。在一些用博弈论等数学工具分析矿池的论文中，“ **加入矿池** 获得的收益 比 **单独挖矿** 获得的收益高”这个非常直观的印象，得到合理的建模与严格的论证。

  类似的结论应该也适用于本 FaaS 平台的算力市场。可以预见，只具有单个计算设备的供应商在性能，服务可用性等多个方面的表现是不如具有多个计算设备的供应商或者多个单设备供应商的联合。也就是说，如果这个 FaaS 平台的算力市场能够得到发展，那么，像矿工形成矿池一样，**一些供应商也会自发地形成“算池”**，已取得相对单设备供应商的优势。

  多个计算设备通过一些技术手段连接，组成一个算池，而对于本 FaaS 平台，整个算池表现为一个单独的供应商，可称为“**算池供应商”**。一些功能不完备的计算设备（比如，没有安装软件栈，没有公有 IP 地址）可以通过算池间接地给 FaaS 平台提供计算资源。

  > 算池里有算池里的信任问题，算池自己去解决。

  

  <img src="./defaas-imgs/Computing-Pool.svg"  />

  

  

- 各种各样的算池

  像 ChainFaaS 这种设计，要求供应商一定要和一个 “Serverless Controller”  交互；从算池角度来看，ChainFaaS 的设计固化了一个“算池”。

  固化一个算池是方便的，但是问题是，我们设计这个 FaaS 平台，并没有很多”知识“：我们不知道什么样的计算设备要参与进来？不知道未来的边缘设备是什么样的？这些设备擅长什么类型的负载？还有它们要怎样连接起来？它们要怎么调度？

  现实**有可能**是这样发展的：

  - 对于云里的服务器，形成适合于服务器管理和连接的算池
  - 对于边缘设备，形成适合于边缘设备管理和连接的算池

  也**有可能**是这样的：

  - 擅长 AI 计算的供应商结成一个算池
  - 擅长图形渲染的供应商结成一个算池
  - 擅长 CDN 的供应商结成一个算池

  

  > 所以，我们不需要把 FaaS 平台 和 一个细节（”供应商具体怎么运行函数服务“）绑定。
  >
  > 和越多的细节绑定，对参与者的具体要求就越多，能参与进来的人就越少；这不是可以掌握的事情。

  

  FaaS 平台对”供应商“的约束非常简单：

  - 能够与链上的合约交互（**只需与合约交互**）
  - 以 HTTP 对外提供函数服务（可以接受外部租户的部署动作，可以被外部访问）

  这是声明式的，不是过程式的，并不要求供应商用什么样的具体过程来运行。

  

  如果基于本平台，供应商自发联合起来形成来“算池”的话，完全有可能形成**各种各样**的“算池”，并且这些算池才是”符合现实“的。

  > 我的想法是，许多东西是控制不住的，我们不用以一己之力托住整个系统，应该关心最重要的东西。
  >
  > FaaS 平台最重要的是，在开放的环境中保住租户和供应商之间的信任，给双方提供桥梁，提供计算资源所有者合作的机会。
  >
  > 而其他的许多东西会在参与中逐渐“自然地“形成。



### 5.2 一种算池供应商的设计

算池供应商可以有多个，它们可能针对不同的场景，应用了不同的技术。

下面介绍一种基于 K8S 的算池供应商设计。



![](./defaas-imgs/K8S-based-Computing-Pool-Provider.svg)







## 6. 不足分析

### 6.1 没有定制区块链（不在逻辑之中，但是影响现实）

本平台作为一个 DApp，所使用的几个智能合约纯粹是一些应用层的东西，没有涉及区块链的底层设计。

粗略来看，只包含应用逻辑的 DApp 似乎可以部署在任何一个区块链上；但实际上，DApp 并不是和区块链底层完全解耦的，DApp 许多的指标会受到区块链底层的限制，比如说安全性，性能。

一种 DApp 的设计趋势是“把构建一个 DApp 当作构建一个针对该 DApp 定制的区块链”，称为 Applications-Specific Blockchains。这种设计理念不同于以太坊（多个  DApp 共享争用同一个公链的资源），在根本上就解决了以太坊所面临的两个难题（扩展性，DApp与平台之间的治理冲突）。

为 DApp 定制区块链（而非选择以太坊之类的共享平台）的好处是显而易见的：

- 可以根据应用的特点选择合适的共识算法，设计合适的共识机制，采用适合的技术底座，进而在安全性，互操作性，吞吐量，可扩展性等多个方面达到一个很好的权衡
- 可以根据应用逻辑的需要做底层区块链的治理，而不会影响其他 DApp



### 6.2 经济危机（逻辑的结果，不可避免）

本平台引入了 FST（FaaS Token）这种代币作为交换计算资源的媒介，也就同时引入资本主义经济的内生缺陷。

下面是本平台不可避免发生经济危机的逻辑：

1. 假设本平台上流通的 FST 的总量是一定的，FST 仅可在本平台内流通，并且不能和任何外部资产汇兑。

2. 假设本平台的参与者数量是一定的，他们各自拥有的计算资源是不等量的。

3. 假设所有参与者在初始时拥有等量的 token；所有参与者在任何时刻都有等量负载的函数服务需求。

4. 随着时间流逝，FaaS 平台的交易 和 FST 的流动将呈现如下趋势：

   - 对于那些计算资源较少的参与者，他们往往缺少计算资源，更多可能成为租户来消费其他参与者的计算资源，更少可能成为供应商来赚取 FST，因此入不敷出；
   - 另一方面，那些计算资源较多的参与者，往往更多可能成为供应商节出售计算资源，更少可能成为租户为购买计算资源，因此只进不出。

5. 按此趋势，FaaS 平台经过一段时间的发展与交易的进行，FST 分布将出现严重失衡。一部分计算资源富余的参与者（供应商类型）积累了绝大部分的 FST，而计算资源匮乏的参与者（租户类型）拥有的 FST 则所剩无几。

   供应商类型不需要购买计算资源，而租户类型已囊中羞涩无力购买，平台上的交易无以为继。这便是表现为交易停滞，通货紧缩，有效需求不足，产能相对过剩的经济危机。在这个情境下，它的根本原因是天然的：计算资源的不平衡导致 FST 流动的失衡。



FaaS 平台的经济系统的这种自我限制，在《资本论》中被论述为资本主义内在界限的两种：

> - 货币是生产的界限
>
>   资本主义生产的最基本特征是，货币的增殖，不同产业之间的关系全部以货币为媒介。生产力的发动，也先要将货币投放。
>
>   当因为货币的流通量不足而无法以货币进行结算，资本主义生产就碰到了它的界限。而这一界限是自己设定的，所以采取超发货币突破这一界限。
>
> - 使用价值的生产受到交换价值的限制
>
>   使用价值是真实的感性财富。由于资本主义生产追求剩余价值，如果某种使用价值带来不了剩余价值，这种使用价值将不会被生产。说明资本主义生产，一方面带来人的实际需要的满足，如果他的这种实际需要的满足不能带来剩余价值，生产就不存在。



上述对经济危机的分析，解释了第四章中“证人的监督报酬来自平台的凭空铸币”这一设计，这一设计相当于有规律且有节制地增发 FST 给证人，可以缓解 FST 的流向失衡。（缺少定量分析。）



小结：市场经济这样一种系统，它内在地具有理性的部分（对等交易的理性过程）和非理性的部分（经济危机的非理性结果）。**区块链技术可以令该系统中理性的部分更加理性，但对非理性的部分通常无能为力，除非使用区块链技术来构建新的系统。**





### 6.3 供应商贿赂证人（可弥补的逻辑漏洞，要在权衡中解决）

在本设计中，由于引入了证人机制和函数鉴权，供应商明确知道负责执行租约 SLA 的证人。

如何防止供应商贿赂证人？

由于证人之间的博弈仅存在两个纳什均衡，供应商的贿赂要成功，供应商需要贿赂大多数（> M）的证人。

可否设计：

- M*证人诚实报酬 > 供应商服务费用
- 把一个订单的服务时长切分为多个部分，每个部分重新抽选证人，增大供应商的贿赂难度。





### 6.4 简化处理了 SLA（可弥补的逻辑漏洞，要在权衡中解决）

- 证人如何检测出供应商在运行函数？
  
- 需要给函数服务预先注入供证人检测钩子（可能是一个哈希字符串的路径），并且这种钩子不能被供应商嗅探到
  
- 证人如何检测出供应商如实运行函数？

  - 需要一些函数的测试例子，最好是可以自动化生成的

- 证人如何检测出供应商有没有如实提供计算资源规格？

  - 有没有一种算法或密码学函数 F，通过一个输入 X 给 F，得到输出 Y = F（X），满足以下条件：
    - 计算 Y 要耗费 CPU 和 大量内存，可使不同规格的计算资源有明显的计算时间的不同（要求供应商在规定时间内返回结果） 
    - 验证 Y 是 X 的结果可以非常快速（让证人可以快速验证）

  我想到的是随机化验证矩阵乘法：https://blog.51cto.com/4747857/1577629





### 6.5 不支持弹性 FaaS（可扩展的逻辑边界，不解决也可以）

如 3.1.1 的注释所述。





## 7. 研究现状和相关工作（提纲）

- https://akash.network/
- https://sonm.com
- Nebula: A Blockchain Based Decentralized Sharing Computing Platform https://link.springer.com/chapter/10.1007%2F978-981-15-2777-7_58
- ChainFaaS: An Open Blockchain-BasedServerless Platform







## 8. 结论

本文介绍了一个 FaaS 平台，它的特点是开放，公平，



## 9. 参考文献









-----------



